CLIENT SIDE

4) Open its own listening port. Client A opens its listening port by calling the accept() function; it needs to do this because other clients may want to connect to it and download file from it.
5) Quit the program. Same as Project 2.
6) The while loop. Client A enters an infinite loop:
	If the user types “f”, client A will ask which file the user wants and the user will input the file index. If the user types in, say, 10, client A first checks if it has file 10. If yes, it prints out a message like “I already have file 10.”
 	
	Otherwise, it sends a message to the server saying that “can you tell me who has file 10?’’ The server will reply with a message with the information of a client, say, client B, who has file 10, including B’s ID, B’s IP address, and B’s listening port number. The server also sends client A the SHA-1 hash of the file.
 	
	Client A will print out the information it receives. Client A will then try to connect to client B by creating a new socket and supplying the IP and port number it received from the server.
 

	After client B accepts the connection, client A will send client B a message saying that “I need file 10.” Client B will then send client A the file in 1000-byte blocks, where client B sleeps for 1 second after sending each block (so the file transfer takes roughly 20 seconds).
 

	After receiving the entire file, client A calls the find_file_hash function to get the hash of the file. Client A prints out the hash along with the hash server gave it. If they match, client A sends the server a message saying that “I have downloaded file 10 from client B.” Client A then sends a positive ACK packet to B closes the connection with client B. If they do not match, client A asks client B to send again, by sending a negative ACK packet which goes on until client A gets the file from client B.
 

	Client A also monitors its listening port. If there is a client, say, client C, trying to connect to it, it will accept the request. Client A will then receive a message from client C containing the index of the file client C needs. It will then send the required file to C. After sending the file, it will wait for a positive ACK or negative ACK from C. If negative, the client will send the file again. Later, when client C closes the connection with client A, client A prints out “closed clientSocket”

	Auxiliary functions. Same as Project 2.
 

SERVER SIDE
4) Update client info. After client A has successfully received a file, it will send a message to the server saying that “I have downloaded file x.” The sever will update the record for client A, i.e., add a 1 to its file vector. If a client leaves, the sever deletes its info.

 
Assumptions
There are a few assumptions that we make in this project.

	There are no real files. The files are generated by the generate_file method and are lost when the program quits.

	The files are being generated pseudorandomly with the seed set to the file_index. You do not need to understand the details of this process, just know that the server will always generate the correct file hash when calling find_file_hash and supplying it with the file index.

	We will assume a client can only receive 1 file at a time. i.e. the client can only make sequential requests for files, while the client is receiving a file, it cannot request another file until the transfer is complete.
	
	The client can however send and receive at the same time. i.e. it can be receiving a file, but also sending other file(s) to multiple other clients. Note, however, that there is nothing extra you need to do here to implement this functionality. Each peer-to-peer interaction happens in its own thread. So as long as your program works perfectly for 1 pair of peers, the threading aspect of this project will automatically take care of multiple requests.

	The positive and negative ACKs are nothing but a simple packet with a boolean field set to true/false.
	
	You can assume the user will not hit quit during the file transfer process. Any quit command will only be issued when the client is not receiving or sending any files.